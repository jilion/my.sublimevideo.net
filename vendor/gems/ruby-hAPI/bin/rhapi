#!/usr/bin/env ruby

require "rubygems"

require "paraopts"

require "hapi"
require "hapi/string_mods"

require "pp"

option_data = [
  {
    :short        => '-U',    :long   => '--hapi-username USERNAME',
    :type         => String,  :key    => :hapi_username,
    :description  => 'hAPI Username',
    :required     => true
  },

  {
    :short        => '-P',    :long   => '--hapi-password PASSWORD',
    :type         => String,  :key    => :hapi_password,
    :description  => 'hAPI Password',
    :required     => true
  },

  {
    :short        => '-H',    :long   => '--hapi-hostname HOSTNAME',
    :type         => String,  :key    => :hapi_hostname,
    :description  => 'hAPI Server Hostname'
  },

  {
    :short        => '-V',    :long   => '--hapi-version VERSION',
    :type         => String,  :key    => :hapi_version,
    :description  => 'hAPI Version'
  },

  {
    :short        => '-A',    :long   => '--[no-]useauthkey',
    :type         => nil, :key    => :useauthkey,
    :description  => 'Are username and password actually key and secret?',
    :default      => false
  },

  {
    :short        => '-m',    :long   => '--method METHOD',
    :type         => String,  :key    => :method,
    :description  => 'hAPI Method Name',
    :required     => true
  },

  {
    :short        => '-p',    :long   => '--method-param PARAM',
    :type         => String,  :key    => :method_param,
    :description  => 'hAPI Method Param in URL encoded format key=val&key2=val2'
  },

  {
    :short        => '-y',    :long   => '--yaml-param PARAMFILE',
    :type         => String,  :key    => :yaml_param,
    :description  => 'hAPI Method Paramaters in YAML Format (FILENAME)'
  },

  {
    :short        => '-r',    :long   => '--repeat INTERVAL',
    :type         => String,  :key    => :repeat,
    :description  => 'Should the method be repeated (loop time in seconds)'
  },

  {
    :short        => '-o',    :long   => '--output-format FORMAT',
    :type         => String,  :key    => :output_format,
    :description  => 'Output format (Defaults to Ruby Array/Hash)',
    :default      => :ruby
  },
]

begin
  opts = ParaOpts.new( File.basename(__FILE__), option_data )

  if ENV.has_key?('HAPI_CONFIG') and File.readable?(ENV['HAPI_CONFIG'])
    opts.parse_file(ENV['HAPI_CONFIG'])
  end

  opts.parse_arguments(ARGV)

  if opts.parsed_options[:useauthkey]
    api = HAPI.new( opts.parsed_options.merge( { :hapi_authkey => { :key => opts.parsed_options[:hapi_username], :secret => opts.parsed_options[:hapi_password] } } ) )
  else
    api = HAPI.new( opts.parsed_options )
  end

  raise "-m / --method is a required option" if opts.parsed_options[:method].nil?

  mparam = Hash.new

  if opts.parsed_options.has_key?(:yaml_param) and File.readable?(opts.parsed_options[:yaml_param])
    File.open(opts.parsed_options[:yaml_param]) { |fh| mparam.reverse_merge! YAML::load( fh ) }
  end

  if opts.parsed_options.has_key?(:method_param)
    opts.parsed_options[:method_param].split('&').each do |kval|
      key, value = kval.split('=')
      mparam[key.to_sym] = value
    end
  end

  ruby_method_parts = []

  opts.parsed_options[:method].split(".").each do |mpart|
    if mpart =~ /_/
      ruby_method_parts << mpart.camelize
    else
      ruby_method_parts << mpart
    end
  end

  if opts.parsed_options.has_key?(:repeat)
    while true
      if opts.parsed_options[:output_format] == :ruby
        pp api.send(ruby_method_parts.join("_"), mparam, { :format => opts.parsed_options[:output_format].to_sym } )
      else
        puts api.send(ruby_method_parts.join("_"), mparam, { :format => opts.parsed_options[:output_format].to_sym } )
      end

      sleep opts.parsed_options[:repeat].to_i
    end
  else
    if opts.parsed_options[:output_format] == :ruby
      pp api.send(ruby_method_parts.join("_"), mparam, { :format => opts.parsed_options[:output_format].to_sym } )
    else
      puts api.send(ruby_method_parts.join("_"), mparam, { :format => opts.parsed_options[:output_format].to_sym } )
    end
  end
rescue OptionParser::ParseError => e
  STDERR.puts e
  exit 1
rescue HAPI::Backend => ex
  STDERR.puts "[ERROR] (#{ex.class.to_s}) #{ex.message}"
  exit 1
rescue StandardError => ex
  STDERR.puts "[ERROR] (#{ex.class.to_s}) #{ex.message}"
  STDERR.puts ex.backtrace
  exit 1
rescue RuntimeError => ex
  STDERR.puts ex.message
  exit 1
rescue SystemExit
  exit 0
rescue Exception => ex
  STDERR.puts "Unhandled Exception: #{ex.class.to_s}"
  STDERR.printf ex.message + "\n\n"
  STDERR.puts "Backtrace:"
  STDERR.puts ex.backtrace
  exit 1
end

